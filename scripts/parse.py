#!/usr/bin/env python3
"""
AsciiDoc to FODT Parser

This program parses a DocBook file generated by asciidoctor and extracts information
to inject everything into a generated FODT file.

AsciiDoctor document header format:
= Title of the document
:asciidoctor_directives:
Author_firstname Lastname <mail@address.com>
version, date : author_initials | Comment (you may write several lines; one per version)
:authortitle: Title of the Author (CTPO for example)
:reviewer: Name of reviewer | Title of the reviewer
:approver: Name of the Approver | Title of the Approver
"""

import sys
import re
import html
import datetime
import xml.etree.ElementTree as ET
from jinja2 import Template
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')


def validate_arguments():
    """Validate command line arguments."""
    if len(sys.argv) != 4:
        print("Usage: parse.py <xml_file> <template_file> <output_file>")
        sys.exit(1)

    xml_file, template_file, output_file = sys.argv[1], sys.argv[2], sys.argv[3]

    # Check if input files exist
    import os
    if not os.path.exists(xml_file):
        print(f"Error: XML file '{xml_file}' does not exist.")
        sys.exit(1)
    if not os.path.exists(template_file):
        print(f"Error: Template file '{template_file}' does not exist.")
        sys.exit(1)

    return xml_file, template_file, output_file


def safe_extract_text(element, default=''):
    """Safely extract text from XML element with HTML escaping."""
    if element is not None and element.text is not None:
        return html.escape(element.text)
    return default


def main():
    """Main function to process DocBook to FODT conversion."""
    # Get and validate arguments
    xml_file, template_file, output_file = validate_arguments()

    # Load and parse XML file
    try:
        tree = ET.parse(xml_file)
        root = tree.getroot()
    except ET.ParseError as e:
        print(f"Error parsing XML file '{xml_file}': {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error loading XML file '{xml_file}': {e}")
        sys.exit(1)

    # Define namespaces
    namespaces = {'doc': 'http://docbook.org/ns/docbook'}

    # Extract main information using safe extraction
    author_firstname = safe_extract_text(root.find('.//doc:firstname', namespaces))
    author_surname = safe_extract_text(root.find('.//doc:surname', namespaces))
    author_email = safe_extract_text(root.find('.//doc:email', namespaces))
    author_initials = safe_extract_text(root.find('.//doc:authorinitials', namespaces))
    title = safe_extract_text(root.find('.//doc:title', namespaces))
    subtitle = safe_extract_text(root.find('.//doc:subtitle', namespaces))

    # Handle date with fallback to current datetime
    date_element = root.find('.//doc:date', namespaces)
    if date_element is not None and date_element.text:
        date = html.escape(date_element.text)
    else:
        date = datetime.datetime.now().strftime('%Y-%m-%d')


def extract_field(simpara, field_name):
    """
    Extract a field value from simpara content based on AsciiDoc field format.

    Args:
        simpara (str): The simpara content to search in
        field_name (str): The field name to extract (without colons)

    Returns:
        str: The field value or empty string if not found
    """
    if not simpara:
        return ''

    for line in simpara.splitlines():
        if line.startswith(f":{field_name}:"):
            return line.split(f":{field_name}:", 1)[1].strip()
    return ''

def parse_simpara_fields(root, namespaces):
    """
    Parse fields from simpara content including authortitle, access, reviewer, approver.

    Returns:
        tuple: (authortitle, access_level, reviewer, reviewertitle, approver, approvertitle, revtable)
    """
    revtable = []
    authortitle = ''
    access_level = 'public'  # Default value
    reviewer = ''
    reviewertitle = ''
    approver = ''
    approvertitle = ''

    simpara_element = root.find('.//doc:simpara', namespaces)
    if simpara_element is None or simpara_element.text is None:
        logging.warning("No simpara content found")
        return authortitle, access_level, reviewer, reviewertitle, approver, approvertitle, revtable

    simpara_content = simpara_element.text

    # Extract fields safely
    authortitle_raw = extract_field(simpara_content, 'authortitle')
    if authortitle_raw:
        authortitle = html.escape(authortitle_raw)

    access_raw = extract_field(simpara_content, 'access')
    if access_raw:
        access_level = html.escape(access_raw)

    # Parse reviewer field
    reviewer_line = extract_field(simpara_content, 'reviewer')
    if reviewer_line and '|' in reviewer_line:
        parts = reviewer_line.split('|', 1)
        reviewer = html.escape(parts[0].strip())
        reviewertitle = html.escape(parts[1].strip())

    # Parse approver field
    approver_line = extract_field(simpara_content, 'approver')
    if approver_line and '|' in approver_line:
        parts = approver_line.split('|', 1)
        approver = html.escape(parts[0].strip())
        approvertitle = html.escape(parts[1].strip())

    # Parse revision table from simpara
    for line in simpara_content.splitlines():
        if line.startswith(':') or not line.strip():
            continue
        try:
            if ',' in line and ':' in line and '|' in line:
                version, rest = line.split(',', 1)
                date_part, rest = rest.split(':', 1)
                author, comment = rest.split('|', 1)
                revtable.append({
                    'version': html.escape(version.strip()),
                    'author': html.escape(author.strip()),
                    'date': html.escape(date_part.strip()),
                    'comment': html.escape(comment.strip()),
                })
        except ValueError as e:
            logging.warning(f"Skipping malformed revision line: {line.strip()}")
            continue

    return authortitle, access_level, reviewer, reviewertitle, approver, approvertitle, revtable


def parse_revhistory(root, namespaces, revtable):
    """
    Parse revision history from DocBook revhistory element.

    Args:
        root: XML root element
        namespaces: XML namespaces dict
        revtable: List to prepend revisions to

    Returns:
        str: Latest revision number or empty string
    """
    revnumber = ''
    revhistory = root.find('.//doc:revhistory', namespaces)

    if revhistory is not None:
        for revision in revhistory.findall('.//doc:revision', namespaces):
            # Safely extract revision data
            revnumber_elem = revision.find('./doc:revnumber', namespaces)
            date_elem = revision.find('./doc:date', namespaces)
            revremark_elem = revision.find('./doc:revremark', namespaces)
            authorinitials_elem = revision.find('./doc:authorinitials', namespaces)

            if revnumber_elem is not None and revnumber_elem.text:
                revnumber = html.escape(revnumber_elem.text.strip())
            else:
                continue  # Skip if no revision number

            date_text = safe_extract_text(date_elem)

            # Handle revremark and author
            if revremark_elem is not None and revremark_elem.text:
                revremark_text = revremark_elem.text.strip()
                if '|' in revremark_text:
                    parts = revremark_text.split('|', 1)
                    author = html.escape(parts[0].strip())
                    comment = html.escape(parts[1].strip())
                else:
                    author = html.escape(revremark_text)
                    comment = ''
            else:
                author = safe_extract_text(authorinitials_elem)
                comment = ''

            # Add revision to the beginning of the table
            revtable.insert(0, {
                'version': revnumber,
                'author': author,
                'date': date_text,
                'comment': comment,
            })

    return revnumber


def treat_admonest(data, admon, tag, puce, style):
    """
    Process admonition blocks in the document.

    Args:
        data (str): The document content to process
        admon (str): The admonition text to display
        tag (str): The tag to search for
        puce (str): The bullet style name
        style (str): The text style name

    Returns:
        str: The processed document content
    """
    # Regular expression to capture <text:p> blocks with variable text
    pattern = (
        fr'<text:p text:style-name="[^"]*">{re.escape(tag)}</text:p>\s*'
        r'<text:p text:style-name="[^"]*">(.*?)</text:p>'
    )

    def replacement(match):
        variable_text = match.group(1)  # Captured variable text
        return (
            f'<text:list text:style-name="{puce}">\n'
            '<text:list-item>\n'
            f'<text:p text:style-name="{style}">{admon}<text:line-break/>{variable_text}</text:p>\n'
            '</text:list-item>\n'
            '</text:list>'
        )

    # Replace occurrences
    return re.sub(pattern, replacement, data, flags=re.DOTALL)


def process_all_admonitions(content):
    """
    Process all admonition types in the document.

    Args:
        content (str): The document content to process

    Returns:
        str: The processed document content
    """
    admonitions = [
        ("Tip", "Tip981267", "Puce_20_Tip", "Tip"),
        ("Important", "Important981267", "Puce_20_Important", "Important"),
        ("Note", "Note981267", "Puce_20_Note", "Note"),
        ("Caution", "Caution981267", "Puce_20_Caution", "Caution"),
        ("Warning", "Warning981267", "Puce_20_Warning", "Warning"),
        ("", "Informalexample981267", "Puce_20_Informalexample", "Informalexample"),
    ]

    for admon, tag, puce, style in admonitions:
        content = treat_admonest(content, admon, tag, puce, style)

    return content


if __name__ == "__main__":
    main()
